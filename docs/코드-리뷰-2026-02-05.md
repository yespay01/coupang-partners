# 코드 리뷰 및 개선 사항

> **작성일**: 2026-02-05
> **대상**: automation-server (독립 서버)
> **총 파일 수**: 22개
> **전체 평가**: ⭐⭐⭐⭐☆ (양호)

---

## 📊 전체 요약

### ✅ 강점
- 코드 구조가 매우 잘 정리되어 있음
- Express.js + PostgreSQL 구조 명확
- JWT 인증 시스템 구현
- JSDoc 주석 잘 작성됨
- 모듈화가 잘 되어 있음

### ⚠️ 개선 필요
- SQL Injection 취약점 존재
- AI 리뷰 생성 미구현
- 에러 처리 일관성 부족
- 트랜잭션 미사용
- 입력 검증 부족

---

## 🚨 크리티컬 이슈 (즉시 수정 필요)

### 1. SQL Injection 취약점

**파일**: `automation-server/src/routes/admin.js:36-37`

**현재 코드**:
```javascript
// ❌ 위험
if (search) {
  conditions.push(`(product_name ILIKE $${paramIdx} OR content ILIKE $${paramIdx} OR title ILIKE $${paramIdx})`);
  params.push(`%${search}%`);
  paramIdx++;
}
```

**문제점**:
- 사용자 입력(`search`)이 직접 쿼리에 삽입
- `%`, `_` 같은 LIKE 특수문자 검증 없음
- 악의적인 패턴으로 모든 데이터 조회 가능

**해결 방법**:
```javascript
// ✅ 개선안
if (search) {
  // LIKE 특수문자 이스케이프
  const sanitizedSearch = search.replace(/[%_\\]/g, '\\$&');

  // 최대 길이 제한
  const trimmedSearch = sanitizedSearch.slice(0, 100);

  conditions.push(`(product_name ILIKE $${paramIdx} OR content ILIKE $${paramIdx} OR title ILIKE $${paramIdx})`);
  params.push(`%${trimmedSearch}%`);
  paramIdx++;
}
```

**적용 위치**:
- `automation-server/src/routes/admin.js` (리뷰 검색)
- `automation-server/src/routes/admin.js` (상품 검색)
- `automation-server/src/routes/admin.js` (로그 검색)

---

### 2. AI 리뷰 생성 미구현

**파일**: `automation-server/src/routes/review.js:40`

**현재 코드**:
```javascript
// ❌ 하드코딩된 텍스트
const content = `${product.product_name}에 대한 리뷰입니다.`;
```

**문제점**:
- 실제 AI API 호출 없음
- 모든 리뷰가 동일한 형식
- OpenAI/Gemini 통합 누락

**해결 방법**:

**1단계**: AI Provider 서비스 사용
```javascript
// ✅ 개선안
import { generateReviewWithAI } from '../services/aiProviders.js';
import { getSystemSettings } from '../services/settingsService.js';

// 시스템 설정 조회
const settings = await getSystemSettings();

// AI로 리뷰 생성
const aiResult = await generateReviewWithAI({
  productName: product.product_name,
  productPrice: product.product_price,
  categoryName: product.category_name,
  provider: settings.ai?.provider || 'openai',
  model: settings.ai?.model || 'gpt-4o-mini',
});

const content = aiResult.content;
const toneScore = aiResult.toneScore || 0.5;
const charCount = content.length;
```

**2단계**: `aiProviders.js` 확인 및 수정
```javascript
// automation-server/src/services/aiProviders.js
export async function generateReviewWithAI(options) {
  const { productName, provider, model } = options;

  if (provider === 'openai') {
    return await generateWithOpenAI(options);
  } else if (provider === 'gemini') {
    return await generateWithGemini(options);
  } else if (provider === 'claude') {
    return await generateWithClaude(options);
  }

  throw new Error(`지원하지 않는 AI provider: ${provider}`);
}
```

**적용 위치**:
- `automation-server/src/routes/review.js` (POST /api/review/generate)

---

### 3. Cron Job 리뷰 생성 미구현

**파일**: `automation-server/src/cron/scheduler.js:32`

**현재 코드**:
```javascript
// ❌ 미구현
cron.schedule('0 3 * * *', async () => {
  console.log('⏰ Running scheduled review generation...');

  try {
    // pending 상품 조회하여 리뷰 생성
    // 이 부분은 별도 엔드포인트 추가 필요
    console.log('Review generation scheduled task - to be implemented');
  } catch (error) {
    console.error('❌ Review generation failed:', error.message);
  }
}, {
  timezone: 'Asia/Seoul'
});
```

**문제점**:
- 자동 리뷰 생성이 작동하지 않음
- pending 상품이 쌓이기만 함

**해결 방법**:

**1단계**: pending 상품 조회 및 리뷰 생성
```javascript
// ✅ 개선안
cron.schedule('0 3 * * *', async () => {
  console.log('⏰ Running scheduled review generation...');

  try {
    // pending 상품 조회
    const response = await axios.get(`${API_BASE}/api/admin/products?statuses=pending&limit=10`);

    if (!response.data.success || response.data.data.products.length === 0) {
      console.log('✅ No pending products to process');
      return;
    }

    const products = response.data.data.products;
    let successCount = 0;
    let failCount = 0;

    // 각 상품에 대해 리뷰 생성
    for (const product of products) {
      try {
        await axios.post(`${API_BASE}/api/review/generate`, {
          productId: product.productId
        });
        successCount++;

        // API rate limit 방지
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        console.error(`❌ Review generation failed for ${product.productId}:`, error.message);
        failCount++;
      }
    }

    console.log(`✅ Review generation completed: ${successCount} success, ${failCount} failed`);

    // Slack 알림
    if (successCount > 0 || failCount > 0) {
      await axios.post(`${API_BASE}/api/admin/notify`, {
        message: `리뷰 자동 생성 완료: 성공 ${successCount}건, 실패 ${failCount}건`,
        level: failCount > 0 ? 'warn' : 'success'
      });
    }
  } catch (error) {
    console.error('❌ Review generation failed:', error.message);
  }
}, {
  timezone: 'Asia/Seoul'
});
```

**2단계**: 상품 상태 업데이트 추가
```javascript
// review.js에서 리뷰 생성 후
await db.query(
  'UPDATE products SET status = $1 WHERE product_id = $2',
  ['reviewed', productId]
);
```

**적용 위치**:
- `automation-server/src/cron/scheduler.js`
- `automation-server/src/routes/review.js` (상품 상태 업데이트 추가)

---

## ⚠️ 중요 이슈 (조만간 수정 필요)

### 4. 에러 처리 불일치

**문제점**:
- 일부는 `console.error`, 일부는 `res.status(500)`
- 에러가 데이터베이스에 저장되지 않음
- 민감한 에러 메시지가 클라이언트에 노출
- Slack 알림이 누락되는 경우 있음

**현재 패턴**:
```javascript
// ❌ 패턴 1
try {
  // ...
} catch (error) {
  console.error('오류:', error);
  res.status(500).json({ success: false, message: error.message });
}

// ❌ 패턴 2
try {
  // ...
} catch (error) {
  await notifySlack(`오류: ${error.message}`, 'error');
  res.status(500).json({ success: false, message: '오류가 발생했습니다.' });
}
```

**해결 방법**:

**1단계**: 중앙화된 에러 핸들러 생성
```javascript
// ✅ automation-server/src/middleware/errorHandler.js
import { getDb } from '../config/database.js';
import { notifySlack } from '../services/slack.js';

/**
 * 에러 로깅 및 처리
 */
export async function handleError(error, context = {}) {
  const errorData = {
    message: error.message,
    stack: error.stack,
    context: JSON.stringify(context),
    timestamp: new Date().toISOString(),
  };

  // 1. 콘솔 로그
  console.error('❌ Error:', errorData);

  // 2. DB에 저장
  try {
    const db = getDb();
    await db.query(
      `INSERT INTO logs (type, level, message, payload, created_at)
       VALUES ($1, $2, $3, $4, NOW())`,
      ['error', 'error', error.message, errorData]
    );
  } catch (logError) {
    console.error('Failed to log error to DB:', logError);
  }

  // 3. Slack 알림 (중요 에러만)
  if (error.severity === 'critical' || context.notifySlack !== false) {
    try {
      await notifySlack(
        `🚨 서버 오류: ${error.message}\n컨텍스트: ${JSON.stringify(context)}`,
        'error'
      );
    } catch (slackError) {
      console.error('Failed to send Slack notification:', slackError);
    }
  }
}

/**
 * Express 에러 핸들러 미들웨어
 */
export function errorMiddleware(error, req, res, next) {
  handleError(error, {
    url: req.url,
    method: req.method,
    body: req.body,
    user: req.user?.id,
  });

  // 클라이언트에는 일반적인 메시지만
  res.status(error.statusCode || 500).json({
    success: false,
    message: process.env.NODE_ENV === 'production'
      ? '서버 오류가 발생했습니다.'
      : error.message,
  });
}
```

**2단계**: 모든 라우트에 적용
```javascript
// ✅ automation-server/src/routes/review.js
import { handleError } from '../middleware/errorHandler.js';

router.post('/generate', async (req, res) => {
  try {
    // ... 로직
  } catch (error) {
    await handleError(error, {
      context: 'review_generation',
      productId: req.body.productId
    });
    res.status(500).json({
      success: false,
      message: '리뷰 생성 중 오류가 발생했습니다.'
    });
  }
});
```

**3단계**: index.js에 글로벌 에러 핸들러 추가
```javascript
// ✅ automation-server/src/index.js
import { errorMiddleware } from './middleware/errorHandler.js';

// 라우트 등록 후
app.use(errorMiddleware);
```

**적용 위치**:
- 새 파일: `automation-server/src/middleware/errorHandler.js`
- 수정: 모든 라우트 파일 (routes/*.js)
- 수정: `automation-server/src/index.js`

---

### 5. 트랜잭션 미사용

**파일**: `automation-server/src/routes/collect.js:23-64`

**현재 코드**:
```javascript
// ❌ 트랜잭션 없이 개별 쿼리
async function saveProduct(product, source) {
  const db = getDb();

  try {
    // 중복 확인
    const existing = await db.query(
      'SELECT id FROM products WHERE product_id = $1',
      [product.productId]
    );

    if (existing.rows.length > 0) {
      return false;
    }

    // 상품 저장
    await db.query(
      `INSERT INTO products (...) VALUES (...)`,
      [...]
    );

    return true;
  } catch (error) {
    console.error('상품 저장 오류:', error);
    return false;
  }
}
```

**문제점**:
- Race condition 발생 가능 (동시에 같은 상품 삽입 시)
- 중복 확인과 삽입 사이에 다른 트랜잭션이 끼어들 수 있음
- 중복 키 에러 발생 가능

**해결 방법**:
```javascript
// ✅ 개선안
async function saveProduct(product, source) {
  const db = getDb();
  const client = await db.connect();

  try {
    await client.query('BEGIN');

    // FOR UPDATE로 행 잠금
    const existing = await client.query(
      'SELECT id FROM products WHERE product_id = $1 FOR UPDATE',
      [product.productId]
    );

    if (existing.rows.length > 0) {
      await client.query('ROLLBACK');
      console.debug(`상품 이미 존재: ${product.productId}`);
      return false;
    }

    // 상품 저장
    await client.query(
      `INSERT INTO products (
        product_id, product_name, product_price, product_image,
        product_url, category_id, category_name, affiliate_url,
        source, status, created_at, updated_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW(), NOW())`,
      [
        product.productId,
        product.product_name,
        product.productPrice,
        product.productImage,
        product.productUrl,
        product.categoryId,
        product.categoryName,
        product.affiliateUrl,
        source,
        'pending'
      ]
    );

    await client.query('COMMIT');
    console.info(`상품 저장: ${product.productName}`);
    return true;
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('상품 저장 오류:', error);
    return false;
  } finally {
    client.release();
  }
}
```

**또는 UPSERT 사용** (더 간단):
```javascript
// ✅ 대안: UPSERT (PostgreSQL 9.5+)
async function saveProduct(product, source) {
  const db = getDb();

  try {
    const result = await db.query(
      `INSERT INTO products (
        product_id, product_name, product_price, product_image,
        product_url, category_id, category_name, affiliate_url,
        source, status, created_at, updated_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW(), NOW())
      ON CONFLICT (product_id) DO NOTHING
      RETURNING id`,
      [
        product.productId,
        product.productName,
        product.productPrice,
        product.productImage,
        product.productUrl,
        product.categoryId,
        product.categoryName,
        product.affiliateUrl,
        source,
        'pending'
      ]
    );

    if (result.rows.length === 0) {
      console.debug(`상품 이미 존재: ${product.productId}`);
      return false;
    }

    console.info(`상품 저장: ${product.productName}`);
    return true;
  } catch (error) {
    console.error('상품 저장 오류:', error);
    return false;
  }
}
```

**적용 위치**:
- `automation-server/src/routes/collect.js` (saveProduct 함수)

---

### 6. 슬러그 생성 취약

**파일**: `automation-server/src/routes/review.js:92`

**현재 코드**:
```javascript
// ❌ 예측 가능하고 SEO에 나쁨
const slug = `review-${reviewId}-${Date.now()}`;
```

**문제점**:
- 순차적이라 다른 리뷰 URL 추측 가능
- SEO에 좋지 않음 (의미 없는 숫자)
- 상품명 정보 없음

**해결 방법**:

**1단계**: Slug 생성 유틸 함수 생성
```javascript
// ✅ automation-server/src/utils/slug.js
/**
 * 한글/영문을 SEO 친화적인 slug로 변환
 */
export function createSlug(text) {
  if (!text) return '';

  // 한글 → 로마자 변환 (간단 버전)
  const koreanToRoman = {
    'ㄱ': 'g', 'ㄴ': 'n', 'ㄷ': 'd', 'ㄹ': 'r', 'ㅁ': 'm',
    'ㅂ': 'b', 'ㅅ': 's', 'ㅇ': '', 'ㅈ': 'j', 'ㅊ': 'ch',
    'ㅋ': 'k', 'ㅌ': 't', 'ㅍ': 'p', 'ㅎ': 'h'
  };

  return text
    .toLowerCase()
    .replace(/[가-힣]/g, (char) => {
      // 간단한 한글 변환 (실제로는 hangul-romanization 라이브러리 사용 권장)
      return char; // 임시
    })
    .replace(/\s+/g, '-')           // 공백 → 하이픈
    .replace(/[^\w가-힣-]/g, '')    // 특수문자 제거
    .replace(/-+/g, '-')            // 중복 하이픈 제거
    .replace(/^-|-$/g, '')          // 앞뒤 하이픈 제거
    .slice(0, 100);                 // 최대 길이 제한
}

/**
 * 고유한 slug 생성 (중복 방지)
 */
export async function createUniqueSlug(db, baseSlug, tableName = 'reviews') {
  let slug = baseSlug;
  let counter = 1;

  // 중복 체크
  while (true) {
    const result = await db.query(
      `SELECT id FROM ${tableName} WHERE slug = $1`,
      [slug]
    );

    if (result.rows.length === 0) {
      return slug; // 중복 없음
    }

    // 중복 있으면 번호 추가
    slug = `${baseSlug}-${counter}`;
    counter++;

    if (counter > 100) {
      // 무한루프 방지
      slug = `${baseSlug}-${Date.now()}`;
      break;
    }
  }

  return slug;
}
```

**2단계**: 라우트에 적용
```javascript
// ✅ automation-server/src/routes/review.js
import { createSlug, createUniqueSlug } from '../utils/slug.js';

router.post('/publish', async (req, res) => {
  try {
    const { reviewId } = req.body;

    if (!reviewId) {
      return res.status(400).json({
        success: false,
        message: 'reviewId가 필요합니다.',
      });
    }

    const db = getDb();

    // 리뷰 조회
    const reviewResult = await db.query(
      'SELECT * FROM reviews WHERE id = $1',
      [reviewId]
    );

    if (reviewResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: '리뷰를 찾을 수 없습니다.',
      });
    }

    const review = reviewResult.rows[0];

    // slug 생성
    const baseSlug = createSlug(review.product_name);
    const slug = await createUniqueSlug(db, baseSlug, 'reviews');

    // 상태 업데이트
    await db.query(
      'UPDATE reviews SET status = $1, slug = $2, published_at = NOW() WHERE id = $3',
      ['published', slug, reviewId]
    );

    res.json({
      success: true,
      message: '리뷰가 게시되었습니다.',
      data: {
        reviewId,
        slug,
      },
    });
  } catch (error) {
    console.error('리뷰 게시 중 오류:', error);
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
});
```

**적용 위치**:
- 새 파일: `automation-server/src/utils/slug.js`
- 수정: `automation-server/src/routes/review.js`

**추가 권장**: 한글 로마자 변환 라이브러리 설치
```bash
npm install hangul-romanization
```

---

## 💡 개선 제안 (선택사항)

### 7. 입력 검증 강화

**현재**:
```javascript
// ❌ 간단한 검증만
if (!productId) {
  return res.status(400).json({ success: false, message: 'productId가 필요합니다.' });
}
```

**개선**:
```javascript
// ✅ express-validator 사용
import { body, validationResult } from 'express-validator';

router.post('/generate',
  [
    body('productId')
      .isString().withMessage('productId는 문자열이어야 합니다.')
      .notEmpty().withMessage('productId가 필요합니다.')
      .trim()
      .isLength({ max: 100 }).withMessage('productId가 너무 깁니다.'),
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }

    // ... 로직
  }
);
```

**설치**:
```bash
cd automation-server
npm install express-validator
```

---

### 8. 환경변수 검증

**추가 권장**:
```javascript
// ✅ automation-server/src/config/validateEnv.js
export function validateEnv() {
  const required = [
    'DATABASE_URL',
    'JWT_SECRET',
    'COUPANG_ACCESS_KEY',
    'COUPANG_SECRET_KEY',
    'COUPANG_PARTNER_ID',
  ];

  const optional = [
    'OPENAI_API_KEY',
    'GEMINI_API_KEY',
    'SLACK_WEBHOOK_URL',
  ];

  // 필수 환경변수 체크
  const missing = required.filter(key => !process.env[key]);

  if (missing.length > 0) {
    console.error(`❌ 필수 환경변수 누락: ${missing.join(', ')}`);
    console.error('💡 .env.example 파일을 참고하여 .env 파일을 생성해주세요.');
    process.exit(1);
  }

  // 선택 환경변수 경고
  const missingOptional = optional.filter(key => !process.env[key]);
  if (missingOptional.length > 0) {
    console.warn(`⚠️  선택 환경변수 누락: ${missingOptional.join(', ')}`);
    console.warn('   일부 기능이 제한될 수 있습니다.');
  }

  // JWT_SECRET 강도 체크
  if (process.env.JWT_SECRET && process.env.JWT_SECRET.length < 32) {
    console.warn('⚠️  JWT_SECRET이 너무 짧습니다. 최소 32자 이상 권장합니다.');
  }

  console.log('✅ 환경변수 검증 완료');
}
```

**적용**:
```javascript
// automation-server/src/index.js
import { validateEnv } from './config/validateEnv.js';

validateEnv(); // 가장 먼저 실행

// 나머지 초기화...
```

---

### 9. Rate Limiting

**추가 권장**:
```javascript
// ✅ automation-server/src/middleware/rateLimiter.js
import rateLimit from 'express-rate-limit';

export const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 100, // 최대 100 요청
  message: {
    success: false,
    message: '너무 많은 요청입니다. 잠시 후 다시 시도해주세요.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // 로그인은 15분에 5번만
  message: {
    success: false,
    message: '로그인 시도가 너무 많습니다. 15분 후 다시 시도해주세요.'
  },
  skipSuccessfulRequests: true, // 성공한 요청은 카운트 안 함
});
```

**적용**:
```javascript
// automation-server/src/index.js
import { apiLimiter, authLimiter } from './middleware/rateLimiter.js';

// 전체 API에 적용
app.use('/api/', apiLimiter);

// 인증 라우트에만 강화된 제한
app.use('/api/auth/login', authLimiter);
app.use('/api/auth/register', authLimiter);
```

**설치**:
```bash
npm install express-rate-limit
```

---

### 10. 구조화된 로깅

**현재**:
```javascript
// ❌ console.log/error
console.log('상품 저장:', product.productName);
console.error('상품 저장 오류:', error);
```

**개선**:
```javascript
// ✅ automation-server/src/utils/logger.js
import { getDb } from '../config/database.js';

class Logger {
  async log(level, type, message, payload = {}) {
    const logData = {
      level,
      type,
      message,
      payload: JSON.stringify(payload),
      timestamp: new Date().toISOString(),
    };

    // 콘솔 출력
    const emoji = { info: 'ℹ️', warn: '⚠️', error: '❌', success: '✅' }[level] || '';
    console.log(`${emoji} [${level.toUpperCase()}] ${type}: ${message}`);

    // DB 저장 (비동기, 실패해도 메인 로직에 영향 없음)
    try {
      const db = getDb();
      await db.query(
        `INSERT INTO logs (type, level, message, payload, created_at)
         VALUES ($1, $2, $3, $4, NOW())`,
        [type, level, message, logData]
      );
    } catch (error) {
      console.error('Failed to save log to DB:', error);
    }
  }

  info(type, message, payload) {
    return this.log('info', type, message, payload);
  }

  warn(type, message, payload) {
    return this.log('warn', type, message, payload);
  }

  error(type, message, payload) {
    return this.log('error', type, message, payload);
  }

  success(type, message, payload) {
    return this.log('success', type, message, payload);
  }
}

export const logger = new Logger();
```

**적용**:
```javascript
// ✅ 사용 예시
import { logger } from '../utils/logger.js';

// 기존
console.log('상품 저장:', product.productName);

// 개선
logger.info('product_saved', '상품 저장 완료', {
  productId: product.productId,
  productName: product.productName,
  source: source
});
```

---

## 📋 우선순위별 체크리스트

### 🔴 즉시 (이번 주)

- [ ] **SQL Injection 방어 추가**
  - [ ] admin.js - 리뷰 검색
  - [ ] admin.js - 상품 검색
  - [ ] admin.js - 로그 검색

- [ ] **AI 리뷰 생성 구현**
  - [ ] aiProviders.js 연동
  - [ ] review.js 수정
  - [ ] 시스템 설정에서 AI provider 읽기

- [ ] **Cron Job 리뷰 생성 구현**
  - [ ] scheduler.js - pending 상품 조회
  - [ ] scheduler.js - 리뷰 생성 루프
  - [ ] review.js - 상품 상태 업데이트

### 🟡 중요 (다음 주)

- [ ] **에러 핸들링 표준화**
  - [ ] middleware/errorHandler.js 생성
  - [ ] 모든 라우트에 적용
  - [ ] index.js에 글로벌 핸들러 추가

- [ ] **트랜잭션 적용**
  - [ ] collect.js - saveProduct 함수
  - [ ] UPSERT 패턴으로 변경

- [ ] **슬러그 생성 개선**
  - [ ] utils/slug.js 생성
  - [ ] review.js 적용
  - [ ] hangul-romanization 설치

### 🟢 개선 (여유 있을 때)

- [ ] **입력 검증 강화**
  - [ ] express-validator 설치
  - [ ] 주요 라우트에 적용

- [ ] **환경변수 검증**
  - [ ] config/validateEnv.js 생성
  - [ ] index.js에서 호출

- [ ] **Rate Limiting**
  - [ ] express-rate-limit 설치
  - [ ] middleware/rateLimiter.js 생성
  - [ ] index.js에 적용

- [ ] **구조화된 로깅**
  - [ ] utils/logger.js 생성
  - [ ] 모든 console.log 교체

---

## 🔧 테스트 체크리스트

각 수정 후 테스트:

### API 테스트
```bash
# Health check
curl http://localhost:4000/health

# 로그인
curl -X POST http://localhost:4000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@coupang.com","password":"admin123"}'

# 상품 수집
curl -X POST http://localhost:4000/api/collect/manual \
  -H "Authorization: Bearer YOUR_TOKEN"

# 리뷰 생성
curl -X POST http://localhost:4000/api/review/generate \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"productId":"test-product-123"}'
```

### 데이터베이스 체크
```sql
-- 상품 확인
SELECT * FROM products ORDER BY created_at DESC LIMIT 5;

-- 리뷰 확인
SELECT * FROM reviews ORDER BY created_at DESC LIMIT 5;

-- 로그 확인
SELECT * FROM logs WHERE level = 'error' ORDER BY created_at DESC LIMIT 10;
```

### 스케줄러 테스트
```javascript
// 수동으로 cron job 실행 (테스트용)
// scheduler.js에 추가
export async function testProductCollection() {
  console.log('🧪 Testing product collection...');
  const response = await axios.post(`${API_BASE}/api/collect/auto`);
  console.log('Result:', response.data);
}
```

---

## 📊 코드 품질 지표

| 항목 | 현재 | 목표 | 개선 후 예상 |
|------|------|------|-------------|
| 보안 | ⭐⭐⭐☆☆ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 안정성 | ⭐⭐⭐☆☆ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐☆ |
| 완성도 | ⭐⭐⭐☆☆ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐☆ |
| 에러처리 | ⭐⭐⭐☆☆ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐☆ |
| 문서화 | ⭐⭐⭐⭐☆ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

---

## 📚 참고 자료

### 보안
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [SQL Injection Prevention](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [Node.js Security Best Practices](https://nodejs.org/en/docs/guides/security/)

### PostgreSQL
- [PostgreSQL Transactions](https://www.postgresql.org/docs/current/tutorial-transactions.html)
- [UPSERT (ON CONFLICT)](https://www.postgresql.org/docs/current/sql-insert.html#SQL-ON-CONFLICT)

### Express.js
- [express-validator](https://express-validator.github.io/docs/)
- [express-rate-limit](https://github.com/express-rate-limit/express-rate-limit)

---

## 💬 질문/이슈 트래킹

수정 중 발생한 이슈나 질문은 아래에 기록:

```markdown
### 2026-02-05
- [ ] Q: AI Provider 연동 시 timeout 설정은?
  - A: (답변 대기)

- [ ] Q: 슬러그 한글 변환 라이브러리 선택?
  - A: hangul-romanization vs korean-romanization

- [ ] Q: Rate limit 설정값 조정 필요?
  - A: 실제 트래픽 보고 조정
```

---

**작성자**: Claude Code
**마지막 업데이트**: 2026-02-05
**다음 리뷰 예정**: 크리티컬 이슈 수정 후
