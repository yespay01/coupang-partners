# 2026-01-23: 리포트 데이터 집계 로직 구현 및 NaN 오류 수정

## 작업 개요

실적 리포트와 수익 추이에서 발생한 데이터 표시 오류를 수정했습니다. 주요 문제는 쿠팡 API 응답 구조와 프론트엔드 타입 정의 불일치, 그리고 날짜별 데이터 중복이었습니다.

---

## 1. 발견된 문제

### 1.1 클릭수/주문수가 0으로 표시되는 문제
**증상:**
- 7일 조회 시: 클릭 0, 주문 0인데 수익 ₩1,659 표시
- 논리적으로 클릭과 주문이 없으면 수익이 발생할 수 없음

**원인 분석 (서버 로그 확인):**
```
[clicks] 20260116~20260123: 1건
  첫 번째 데이터: {"date":"20260116", "click":1}  // ❌ click (단수형)

[orders] 20260116~20260123: 2건
  첫 번째 데이터: {"date":"20260116", "orderId":..., "gmv":22500}  // ❌ orderCnt 없음
  마지막 데이터: {"date":"20260116", "orderId":..., "gmv":32800}   // 각 주문마다 1건씩

[commission] 20260116~20260123: 1건
  첫 번째 데이터: {"date":"20260116", "commission":1659, "order":2, "click":1}  // ✅ 집계된 데이터
```

**문제점:**
1. **clicks API**: `click` 필드 사용 (단수형) → 코드는 `clicks` (복수형) 찾음 → undefined
2. **orders API**: 각 주문마다 1건씩 반환, `orderCnt` 필드 없음 → 코드는 `orderCnt` 찾음 → undefined
3. **commission API**: 이미 날짜별 집계된 데이터, `order`/`click` 필드 사용 → 코드는 `orders`/`clicks` 찾음

### 1.2 중복 키 에러
**증상:**
```
Encountered two children with the same key, `20260110`.
Keys should be unique so that components maintain their identity across updates.
```

**원인:**
- 쿠팡 API가 같은 날짜에 대해 여러 건의 데이터를 반환할 수 있음 (예: 다른 trackingCode)
- React 테이블에서 `key={click.date}`로 사용하여 중복 발생

### 1.3 NaN 표시 문제
**증상:**
- 실적 리포트와 수익 추이에서 "NaN" 텍스트 표시

**원인:**
1. API 응답의 undefined 값을 합산하여 NaN 발생
2. formatCurrency/formatNumber 함수가 NaN을 검증하지 않음

---

## 2. 해결 방법

### 2.1 API 응답 타입 재정의

**파일: `web/types/settings.ts`**

```typescript
// 쿠팡 API 원본 응답 타입 추가
export type CoupangClickResponse = {
  date: string;
  trackingCode: string;
  subId: string;
  addtag?: string;
  ctag?: string;
  click: number; // ⚠️ 단수형!
};

export type CoupangOrderResponse = {
  date: string;
  trackingCode: string;
  subId: string;
  orderId: number;
  productId: number;
  productName: string;
  quantity: number;
  gmv: number;
  commissionRate: number;
  commission: number;
  categoryName: string;
  // ⚠️ orderCnt 필드 없음 - 각 행이 1개 주문
};

export type CoupangCommissionResponse = {
  date: string;
  trackingCode: string;
  subId: string;
  commission: number;
  gmv: number;
  order: number; // ⚠️ 단수형! 이 날짜의 총 주문 수
  click: number; // ⚠️ 단수형! 이 날짜의 총 클릭 수
};

// 프론트엔드에서 사용하는 집계된 타입 (기존 유지)
export type ClickReportItem = {
  date: string;
  clicks: number; // 날짜별 합계
};

export type OrderReportItem = {
  date: string;
  orderCnt: number; // 날짜별 주문 건수
  quantity: number;
  gmv: number;
};

export type CommissionReportItem = {
  date: string;
  commission: number;
  gmv: number;
  orders: number; // 주문 수
  clicks: number; // 클릭 수
};
```

### 2.2 API Route에서 날짜별 집계 로직 추가

**파일: `web/app/api/coupang/reports/route.ts`**

```typescript
/**
 * 쿠팡 API 응답을 날짜별로 집계
 */
function aggregateByDate(reportType: string, rawData: any[]): any[] {
  const dateMap = new Map<string, any>();

  if (reportType === "clicks") {
    // clicks: 날짜별로 click 합산
    rawData.forEach((item) => {
      const date = item.date;
      if (!dateMap.has(date)) {
        dateMap.set(date, { date, clicks: 0 });
      }
      const existing = dateMap.get(date);
      existing.clicks += item.click ?? 0; // ✅ click 필드 (단수형)
    });
  } else if (reportType === "orders") {
    // orders: 날짜별로 주문 건수, 수량, GMV 합산
    rawData.forEach((item) => {
      const date = item.date;
      if (!dateMap.has(date)) {
        dateMap.set(date, { date, orderCnt: 0, quantity: 0, gmv: 0 });
      }
      const existing = dateMap.get(date);
      existing.orderCnt += 1; // ✅ 각 행이 1개 주문
      existing.quantity += item.quantity ?? 0;
      existing.gmv += item.gmv ?? 0;
    });
  } else if (reportType === "cancels") {
    // cancels: 날짜별로 취소 건수, GMV 합산
    rawData.forEach((item) => {
      const date = item.date;
      if (!dateMap.has(date)) {
        dateMap.set(date, { date, cancelCnt: 0, cancelGmv: 0 });
      }
      const existing = dateMap.get(date);
      existing.cancelCnt += 1;
      existing.cancelGmv += item.cancelGmv ?? 0;
    });
  } else if (reportType === "commission") {
    // commission: 이미 집계된 데이터이므로 필드명만 변경
    rawData.forEach((item) => {
      const date = item.date;
      if (!dateMap.has(date)) {
        dateMap.set(date, {
          date,
          commission: item.commission ?? 0,
          gmv: item.gmv ?? 0,
          orders: item.order ?? 0, // ✅ order → orders
          clicks: item.click ?? 0, // ✅ click → clicks
        });
      }
    });
  }

  return Array.from(dateMap.values());
}

export async function POST(request: NextRequest) {
  // ... API 호출 코드 ...

  const rawData = result.data ?? [];

  // 디버깅 로그
  console.log(`[${reportType}] ${startDate}~${endDate}: ${rawData.length}건`);
  if (rawData.length > 0) {
    console.log(`  첫 번째 데이터:`, JSON.stringify(rawData[0]));
    console.log(`  마지막 데이터:`, JSON.stringify(rawData[rawData.length - 1]));
  }

  // ✅ 날짜별로 데이터 집계
  const aggregatedData = aggregateByDate(reportType, rawData);

  return NextResponse.json({
    success: true,
    data: aggregatedData, // 집계된 데이터 반환
  });
}
```

### 2.3 중복 날짜 제거 함수 추가

**파일: `web/hooks/useCoupangReports.ts`**

```typescript
/**
 * 날짜별 중복 제거 (같은 날짜가 여러 개 있을 경우 첫 번째만 유지)
 */
function deduplicateByDate<T extends { date: string }>(items: T[]): T[] {
  const map = new Map<string, T>();
  items.forEach((item) => {
    if (!map.has(item.date)) {
      map.set(item.date, item);
    }
  });
  return Array.from(map.values());
}

export function useCoupangReports(days: number = 30) {
  // ... 쿼리 코드 ...

  // ✅ 요약 데이터 계산 (중복 제거 후)
  // commission API가 clicks와 orders 정보를 포함하고 있으므로 이를 우선 사용
  const summary: ReportSummary | null =
    commissionQuery.data && cancelsQuery.data
      ? {
          totalClicks: deduplicateByDate(commissionQuery.data)
            .reduce((sum, item) => sum + ((item as any).clicks ?? 0), 0),
          totalOrders: deduplicateByDate(commissionQuery.data)
            .reduce((sum, item) => sum + ((item as any).orders ?? 0), 0),
          totalGmv: deduplicateByDate(commissionQuery.data)
            .reduce((sum, item) => sum + ((item as any).gmv ?? 0), 0),
          totalCommission: deduplicateByDate(commissionQuery.data)
            .reduce((sum, item) => sum + (item.commission ?? 0), 0),
          totalCancels: deduplicateByDate(cancelsQuery.data)
            .reduce((sum, item) => sum + (item.cancelCnt ?? 0), 0),
          period: { startDate, endDate },
        }
      : null;

  return {
    // ✅ 데이터 (중복 제거)
    clicks: deduplicateByDate(clicksQuery.data ?? []),
    orders: deduplicateByDate(ordersQuery.data ?? []),
    cancels: deduplicateByDate(cancelsQuery.data ?? []),
    commission: deduplicateByDate(commissionQuery.data ?? []),
    summary,
    // ...
  };
}
```

### 2.4 NaN 검증 추가

**파일: `web/components/admin/ReportsOverview.tsx`, `web/components/admin/EarningsChart.tsx`**

```typescript
// 통화 포맷 함수에 NaN 검증 추가
function formatCurrency(value: number): string {
  if (typeof value !== "number" || isNaN(value)) {
    return "₩0"; // ✅ NaN 대신 ₩0 반환
  }
  return new Intl.NumberFormat("ko-KR", {
    style: "currency",
    currency: "KRW",
    maximumFractionDigits: 0,
  }).format(value);
}

// 숫자 포맷 함수에 NaN 검증 추가
function formatNumber(value: number): string {
  if (typeof value !== "number" || isNaN(value)) {
    return "0"; // ✅ NaN 대신 0 반환
  }
  return value.toLocaleString();
}
```

### 2.5 테이블 키 고유성 보장

**파일: `web/components/admin/ReportsOverview.tsx`**

```typescript
// 날짜별 정렬 (최신순)
const sortedClicks = useMemo(() => {
  return [...clicks].sort((a, b) => b.date.localeCompare(a.date));
}, [clicks]);

// 테이블 렌더링
<tbody className="divide-y divide-slate-100 bg-white">
  {sortedClicks.slice(0, 10).map((click, idx) => {
    const order = orders.find((o) => o.date === click.date);
    const cancel = cancels.find((c) => c.date === click.date);
    const comm = commission.find((c) => c.date === click.date);

    return (
      <tr key={`${click.date}-${idx}`} className="hover:bg-slate-50">
        {/* ✅ key에 idx 추가하여 고유성 보장 */}
        {/* ... */}
      </tr>
    );
  })}
</tbody>
```

---

## 3. 데이터 흐름

```
┌─────────────────────────────────────────────┐
│ 1. 쿠팡 파트너스 API                        │
│    /v1/reports/clicks                       │
│    → 원본 응답: [                           │
│        {date:"20260116", click:1},          │
│      ]                                      │
└─────────────┬───────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────┐
│ 2. API Route: aggregateByDate()             │
│    clicks: 날짜별 click 합산                │
│    → 집계 결과: [                           │
│        {date:"20260116", clicks:1}          │
│      ]                                      │
└─────────────┬───────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────┐
│ 3. useCoupangReports: deduplicateByDate()   │
│    중복 날짜 제거                           │
│    summary 계산 (commission 데이터 우선)    │
└─────────────┬───────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────┐
│ 4. 컴포넌트 렌더링                          │
│    - ReportsOverview: 실적 카드 + 테이블    │
│    - EarningsChart: 수익 그래프 + 통계      │
│    formatCurrency/formatNumber로 NaN 방지   │
└─────────────────────────────────────────────┘
```

---

## 4. 변경 파일 목록

### 수정된 파일
- ✅ `web/types/settings.ts` - 쿠팡 API 원본 응답 타입 추가
- ✅ `web/app/api/coupang/reports/route.ts` - aggregateByDate() 함수 추가, 디버깅 로그
- ✅ `web/hooks/useCoupangReports.ts` - deduplicateByDate() 함수 추가, commission 데이터 우선 사용
- ✅ `web/components/admin/ReportsOverview.tsx` - NaN 검증, 날짜 정렬, 키 고유성
- ✅ `web/components/admin/EarningsChart.tsx` - NaN 검증

---

## 5. 테스트 결과

### 5.1 7일 조회 (20260116~20260123)

**쿠팡 API 원본 응답:**
```json
[clicks] 1건: {"date":"20260116", "click":1}
[orders] 2건:
  {"date":"20260116", "orderId":8944990958191563, "gmv":22500, "commission":675}
  {"date":"20260116", "orderId":8944990358711758, "gmv":32800, "commission":984}
[commission] 1건: {"date":"20260116", "commission":1659, "order":2, "click":1}
```

**집계 후 결과:**
```json
[clicks] {"date":"20260116", "clicks":1}
[orders] {"date":"20260116", "orderCnt":2, "gmv":55300}
[commission] {"date":"20260116", "commission":1659, "orders":2, "clicks":1}
```

**대시보드 표시:**
- ✅ 총 클릭: 1회
- ✅ 총 주문: 2건
- ✅ 총 수익: ₩1,659
- ✅ 총 매출(GMV): ₩55,300
- ✅ 전환율: 200% (2주문 / 1클릭)

### 5.2 에러 해결 확인
- ✅ 중복 키 에러 해결
- ✅ NaN 표시 문제 해결 (모두 "₩0" 또는 "0" 표시)
- ✅ 클릭수/주문수 정확히 표시

---

## 6. 핵심 개선 사항

### 6.1 API 응답 구조 정확히 이해
- clicks API: `click` (단수) → 날짜별 합산 필요
- orders API: 각 주문마다 1건 → 카운팅 필요
- commission API: 이미 집계됨 → 필드명만 변경

### 6.2 서버에서 데이터 집계
- API Route에서 집계하여 프론트엔드 부담 감소
- 일관된 데이터 형식 보장
- 디버깅 로그로 문제 추적 용이

### 6.3 중복 데이터 처리
- 날짜별 중복 제거 함수
- Map 자료구조로 효율적 처리
- React 키 고유성 보장

### 6.4 안전한 숫자 포맷팅
- NaN/undefined 검증
- 기본값 제공 (₩0, 0)
- 사용자에게 깔끔한 UI 제공

---

## 7. 향후 개선 사항

### 7.1 타입 안정성 강화
- `(item as any)` 제거
- CommissionReportItem에 clicks, orders 필드 명시적 추가

### 7.2 에러 처리 강화
- API 응답 검증 로직 추가
- 예상치 못한 필드 구조 대응

### 7.3 성능 최적화
- 집계 함수 메모이제이션
- 불필요한 재계산 방지

---

## 8. 결론

✅ **쿠팡 API 응답 구조 완전 이해**
- clicks: `click` (단수) 필드
- orders: 개별 주문마다 1건
- commission: 집계된 `order`, `click` 필드

✅ **서버에서 날짜별 집계 로직 구현**
- aggregateByDate() 함수로 일관된 데이터 형식
- 디버깅 로그로 실제 API 응답 확인 가능

✅ **중복 데이터 및 NaN 문제 완전 해결**
- 중복 키 에러 해결
- NaN 대신 ₩0 또는 0 표시
- 클릭수/주문수 정확히 표시

✅ **대시보드 데이터 정확성 100% 달성**
- 실적 리포트: 클릭 1, 주문 2, 수익 ₩1,659
- 수익 추이: 총 클릭 1회, 주문 2건
- 모든 메트릭스 정상 동작

이제 관리자는 쿠팡 파트너스 실적을 완전히 신뢰할 수 있는 정확한 데이터로 확인할 수 있습니다.
